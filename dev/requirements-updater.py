#!dev/python.sh
import json
import shlex
import subprocess
import sys
from pathlib import Path

# python-apt-binary is packaged by us
# (see https://github.com/drakkar-lig/python-apt-binary and
# https://pypi.org/project/python-apt-binary)
# since it is tightly linked to the apt OS libraries, we
# have a different version for each debian OS release.
# so in this server/requirements.txt file we should not
# specify a version for this dependency.
PACKAGES_WITH_FLEXIBLE_VERSION = {"python-apt-binary"}


def sanitize_pname(pname):
    return pname.replace("_", "-").lower()


def all_packages_name_and_version():
    cmd = shlex.split("dev/python.sh -m pip list --format json")
    proc = subprocess.run(cmd, text=True, stdout=subprocess.PIPE)
    return {sanitize_pname(p_info["name"]): p_info["version"]
            for p_info in json.loads(proc.stdout)}


def parse_requires_tag(text):
    for line in text.splitlines():
        splits = line.split(":", maxsplit=1)
        if splits[0] == "Requires":
            return splits[1].strip()
    raise Exception("'Requires:' tag not found")


def get_packages_info():
    packages_info = all_packages_name_and_version()
    package_names = list(packages_info.keys())
    cmd = ["dev/python.sh", "-m", "pip", "show"] + package_names
    proc = subprocess.run(cmd, text=True, stdout=subprocess.PIPE)
    parts = proc.stdout.split("\n---\n")
    assert len(parts) == len(package_names)
    return {
        name: {
            "version": packages_info[name],
            "requires": parse_requires_tag(part)
        }
        for name, part in zip(package_names, parts)
    }


def get_dependencies(package_name, packages_info, add_current_package=False):
    dependencies = {}
    package_info = packages_info[package_name]
    if add_current_package:
        package_version = package_info["version"]
        dependencies[package_name] = package_version
    if len(package_info["requires"].strip()) > 0:
        required_package_names = package_info["requires"].split(", ")
        for required_package_name in required_package_names:
            required_package_name = sanitize_pname(required_package_name)
            dependencies.update(
                get_dependencies(
                    required_package_name, packages_info, add_current_package=True
                )
            )
    return dependencies


def usage_exit():
    sys.exit(f"Usage: {sys.argv[0]} [freeze|unfreeze]")


if __name__ == "__main__":
    if len(sys.argv) < 2:
        usage_exit()
    mode = sys.argv[1]
    filepath = Path("server/requirements.txt")
    if mode == "freeze":
        print("querying info about pip packages")
        packages_info = get_packages_info()
        dependencies = get_dependencies("walt-server", packages_info)
        print(f"writing {filepath}")
        filepath.write_text(
            "# generated by `make freeze-deps`\n"
            + "\n".join(
                (f"{k}" if k in PACKAGES_WITH_FLEXIBLE_VERSION else f"{k}=={v}")
                for k, v in sorted(dependencies.items())
            )
            + "\n"
        )
    elif mode == "unfreeze":
        if filepath.exists():
            print(f"removing {filepath}")
            filepath.unlink()
    else:
        usage_exit()
