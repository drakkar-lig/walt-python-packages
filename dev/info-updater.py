#!dev/python.sh
import sys, os, re
from collections import OrderedDict

sys.path.append(os.getcwd())
from dev.tools.pretty import pprint_dict
from dev.metadata import PACKAGE_GENERIC_INFO, PACKAGE_SPECIFIC_INFO
from pathlib import Path

info_file_template = """\
# auto-generated by dev/info-updater.py
# using metadata from dev/metadata.py

SETUP_INFO = %(setup_info)s
"""

# read __version__ variable
exec(
    compile(
        open('common/walt/common/version.py').read(),
        'common/walt/common/version.py', 'exec'))

# generate info.py in each pypi package directory
versions_info = dict(upload=__version__)

for package_name, package_specific in PACKAGE_SPECIFIC_INFO.items():
    subdir = Path(package_specific['subdir'])

    setup_info = OrderedDict()
    setup_info.update(name=package_name)
    version = package_specific['version_str'] % versions_info
    setup_info.update(version=version)
    requirements_txt = subdir / 'requirements.txt'
    if requirements_txt.exists():
        uncommented = re.sub(r'#[^\n]*\n', '', requirements_txt.read_text())
        install_requires = uncommented.strip().splitlines()
    else:
        install_requires = [requirement % versions_info
                            for requirement in package_specific['requires']]
    setup_info.update(install_requires=install_requires)
    if 'extras_require' in package_specific:
        extras_require = {
            feature: [(req % versions_info) for req in requirements]
            for (feature, requirements) in package_specific['extras_require'].items()
        }
        setup_info.update(extras_require=extras_require)
    setup_info.update(sorted(PACKAGE_GENERIC_INFO.items()))
    setup_info.update(sorted(package_specific['setup'].items()))
    subdir_as_path = str(subdir).replace('-', '/')
    info_py = subdir / 'walt' / subdir_as_path / 'info.py'
    info_py.write_text(f"""\
# auto-generated by dev/info-updater.py
# using metadata from dev/metadata.py

SETUP_INFO = {pprint_dict(setup_info)}
""")
