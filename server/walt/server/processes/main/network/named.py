import os, time, re
from collections import defaultdict
from pathlib import Path

from walt.server.processes.main.network.service import ServiceRestarter
from walt.server.tools import get_dns_servers, get_server_ip, get_walt_subnet, ip

NAMED_STATE_DIR = Path("/var/lib/walt/services/named")
NAMED_CONF = NAMED_STATE_DIR / "named.conf"
NAMED_WALT_FWD_ZONE = "walt.forward.zone"
NAMED_WALT_REV_ZONE_PATTERN = "walt.%(rev_zone_name)s.reverse.zone"
NAMED_PID_FILE = "/run/walt/named/named.pid"

def dump_warning(comment_char='#'):
    return """
#
# DO NOT EDIT THIS FILE
#
# It is automatically generated by the walt system
# and updated when needed.
#
""".replace('#', comment_char)

CONF_PATTERN = dump_warning() + """

options {
    directory "%(named_state_dir)s";
    pid-file "%(named_pid_file)s";
    listen-on { %(walt_server_ip)s; };
    listen-on-v6 { none; };
    forwarders {
        %(dns_forwarders)s;
    };
};

# avoid failure trying to read /etc/bind/rndc.key
controls {};
# don't return IPv6 addresses to walt nodes
server ::/0 { bogus yes; };

zone "walt" IN {
    type master;
    file "%(named_walt_fwd_zone)s";
    allow-update { none; };
};

%(rev_zones)s

include "/etc/bind/named.conf.default-zones";
"""

# if we have more than a /24, we will get several
# reverse zones

REV_ZONE_DECL_PATTERN = """
zone "%(rev_zone_name)s" IN {
    type master;
    file "%(rev_zone_file)s";
    allow-update { none; };
};
"""

WALT_FWD_ZONE_PATTERN = dump_warning(";") + """
;
; BIND data file for walt zone
;
$TTL    604800
@   IN  SOA server.walt. root.server.walt. (
         %(serial)s     ; Serial
             604800     ; Refresh
              86400     ; Retry
            2419200     ; Expire
             604800 )   ; Negative Cache TTL
;
@                            IN NS    server.walt.
walt-server                  IN CNAME server

"""

WALT_REV_ZONE_PATTERN = dump_warning(";") + """
;
; BIND data file for walt %(rev_zone_name)s reverse zone
;
$TTL    604800
@   IN  SOA server.walt. root.server.walt. (
         %(serial)s     ; Serial
             604800     ; Refresh
              86400     ; Retry
            2419200     ; Expire
             604800 )   ; Negative Cache TTL
;
@   IN NS  server.walt.

"""


def serial_removed(zone_content):
    return re.sub(r'^.*Serial$', '', zone_content, flags=re.MULTILINE)


def identity(x):
    return x


def possibly_update_file(file_path, new_content, diff_preprocessing = identity):
    old_content = ""
    if file_path.exists():
        old_content = file_path.read_text()
    if diff_preprocessing(new_content) != diff_preprocessing(old_content):
        file_path.parent.mkdir(parents=True, exist_ok=True)
        file_path.write_text(new_content)
        return True  # yes, updated
    return False


def update_named_conf(devices):
    changed = False
    serial = str(int(time.time()))
    fwd_zone = WALT_FWD_ZONE_PATTERN % dict(
            serial = serial
    )
    hosts_per_rev_zone = defaultdict(list)
    for dev in devices:
        ip = dev.ip
        if dev.type == 'server':
            name = 'server'
        else:
            name = dev.name
        # ex: 192.168.222.6 -> 222.168.192.in-addr.arpa
        rev_zone_name = '.'.join(reversed(ip.split('.')[:3]))
        rev_zone_name += '.in-addr.arpa'
        ip_last_byte = ip.split('.')[-1]
        hosts_per_rev_zone[rev_zone_name].append((ip_last_byte, name))
        fwd_zone += f'{name:28s} IN A     {ip}\n'
    fwd_zone_file = NAMED_STATE_DIR / NAMED_WALT_FWD_ZONE
    changed |= possibly_update_file(fwd_zone_file, fwd_zone,
                   diff_preprocessing=serial_removed)
    rev_zone_files = set()
    rev_zone_decls = []
    for rev_zone_name, hosts in hosts_per_rev_zone.items():
        rev_zone_file = NAMED_STATE_DIR / (
                NAMED_WALT_REV_ZONE_PATTERN % dict(
                    rev_zone_name = rev_zone_name
                )
        )
        rev_zone_files.add(rev_zone_file)
        rev_zone_decl = REV_ZONE_DECL_PATTERN % dict(
                rev_zone_name = rev_zone_name,
                rev_zone_file = rev_zone_file
        )
        rev_zone_decls.append(rev_zone_decl)
        rev_zone_content = WALT_REV_ZONE_PATTERN % dict(
                serial = serial,
                rev_zone_name = rev_zone_name
        )
        for ip_last_byte, name in hosts:
            rev_zone_content += f'{ip_last_byte:3s} IN PTR {name}.walt.\n'
        changed |= possibly_update_file(rev_zone_file, rev_zone_content,
                   diff_preprocessing=serial_removed)
    # remove obsolete zone files
    for rev_zone_file in list(NAMED_STATE_DIR.glob('walt.*.reverse.zone')):
        if rev_zone_file not in rev_zone_files:
            rev_zone_file.unlink()
            changed = True
    dns_forwarders = map(str, get_dns_servers())
    conf = CONF_PATTERN % dict(
            named_state_dir = NAMED_STATE_DIR,
            named_pid_file = NAMED_PID_FILE,
            walt_server_ip = get_server_ip(),
            dns_forwarders = '; '.join(dns_forwarders),
            named_walt_fwd_zone = NAMED_STATE_DIR / NAMED_WALT_FWD_ZONE,
            rev_zones = "\n".join(rev_zone_decls)
    )
    changed |= possibly_update_file(NAMED_CONF, conf)
    return changed


QUERY_DEVICES_WITH_IP = """
    SELECT ip, name, type
    FROM devices
    WHERE ip IS NOT NULL ORDER BY ip::inet;
"""


class DNSServer:
    def __init__(self, db, ev_loop):
        self.db = db
        self.restarter = ServiceRestarter(ev_loop,
                "named", "walt-server-named.service", allow_reload=True)

    def update(self, force=False, cb=None):
        subnet = get_walt_subnet()
        devices = [
                item for item in self.db.execute(QUERY_DEVICES_WITH_IP) \
                        if ip(item.ip) in subnet
        ]
        changed = update_named_conf(devices)
        if changed | force:
            self.restarter.restart(cb=cb)
        else:
            if cb is not None:
                cb()

    def wf_update(self, wf, force=False, **env):
        self.update(force=force, cb=wf.next)
