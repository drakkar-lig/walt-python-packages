#!/usr/bin/env python
from walt.server import const
from walt.server.threads.main.network.netsetup import NetSetup
from walt.server.threads.main.network.tools import ip, net, get_walt_subnet, get_dns_servers
from operator import itemgetter
from itertools import groupby
from walt.common.tools import do

DHCPD_CONF_FILE = '/etc/dhcp/dhcpd.conf'

CONF_PATTERN = """
#
# DO NOT EDIT THIS FILE
#
# It is automatically generated by the walt system
# and updated when needed.
#

# global parameters
authoritative; # allow sending DHCP NAKs
next-server %(walt_server_ip)s;
option tftp-server-name "%(walt_server_ip)s";
option broadcast-address %(subnet_broadcast)s;

class "rpi-pxe" {
    match if (((binary-to-ascii(16,8,":",substring(hardware, 1, 3)) = "b8:27:eb") or
               (binary-to-ascii(16,8,":",substring(hardware, 1, 3)) = "dc:a6:32")) and
              (option vendor-class-identifier = "PXEClient:Arch:00000:UNDI:002001"));
    option vendor-class-identifier "PXEClient";
    option vendor-encapsulated-options "Raspberry Pi Boot";
}

# walt unregistered devices
subnet %(subnet_ip)s netmask %(subnet_netmask)s {
    # declare ranges of unallocated addresses
%(walt_unallocated_ranges_conf)s

    # check if the ip is already used
    ping-check = 1;

    # no need to recheck often if you are now registered
    min-lease-time 6000000;
    max-lease-time 6000000;
    default-lease-time 6000000;

    # get the vendor class identifier if available
    if exists vendor-class-identifier {
        set vci = option vendor-class-identifier;
    } else {
        set vci = "";
    }

    # get the user class identifier if available
    if exists user-class {
        set uci = option user-class;
    } else {
        set uci = "";
    }

    # when we assign a new IP address, let walt register
    # this new device
    on commit {
        set ip_string = binary-to-ascii(10, 8, ".", leased-address);
        # note: we ensure all 6 bytes of the mac address are left padded with 0 if needed
        # (binary-to-ascii would not output '0e' but just 'e').
        set mac_address_string = concat (
            suffix (concat ("0", binary-to-ascii (16, 8, "", substring(hardware,1,1))),2), ":",
            suffix (concat ("0", binary-to-ascii (16, 8, "", substring(hardware,2,1))),2), ":",
            suffix (concat ("0", binary-to-ascii (16, 8, "", substring(hardware,3,1))),2), ":",
            suffix (concat ("0", binary-to-ascii (16, 8, "", substring(hardware,4,1))),2), ":",
            suffix (concat ("0", binary-to-ascii (16, 8, "", substring(hardware,5,1))),2), ":",
            suffix (concat ("0", binary-to-ascii (16, 8, "", substring(hardware,6,1))),2)
        );
        execute("/usr/local/bin/walt-dhcp-event", "commit", vci, uci,
                        ip_string, mac_address_string);
    }
}

# walt registered devices

# switches
group {
%(walt_registered_switches_conf)s
}

# nodes with netsetup = "LAN"
group {
%(walt_registered_lan_nodes_conf)s
}

# nodes with netsetup = "NAT"
group {
    option routers %(walt_server_ip)s;
    option domain-name-servers %(dns_servers)s;

%(walt_registered_nat_nodes_conf)s
}

# unknown devices
group {
%(walt_registered_unknowns_conf)s
}
"""

RANGE_CONF_PATTERN = "    range %(first)s %(last)s;"

NODE_CONF_PATTERN = """\
    host %(hostname)s {
        hardware ethernet %(mac)s;
        fixed-address %(ip)s;
        option host-name "%(hostname)s";
    }
"""

SWITCH_CONF_PATTERN = """\
    host %(hostname)s {
        hardware ethernet %(mac)s;
        fixed-address %(ip)s;
    }
"""

UNKNOWNS_CONF_PATTERN = """\
    host %(hostname)s {
        hardware ethernet %(mac)s;
        fixed-address %(ip)s;
    }
"""

# see http://stackoverflow.com/questions/2154249/identify-groups-of-continuous-numbers-in-a-list
def get_contiguous_ranges(ips):
    ranges=[]
    for k, g in groupby(enumerate(ips), lambda i_x:i_x[0]-int(i_x[1])):
        group = list(map(itemgetter(1), g))
        ranges.append((group[0], group[-1]))
    return ranges

def generate_dhcpd_conf(subnet, devices):
    switches_confs = []
    lan_nodes_confs = []
    nat_nodes_confs = []
    unknowns_confs = []
    free_ips = list(subnet.hosts())
    server_ip = free_ips.pop(0)
    for device_info in devices:
        if device_info['type'] == 'switch':
            switches_confs.append(SWITCH_CONF_PATTERN % device_info)
        elif device_info['type'] == 'node':
            conf = NODE_CONF_PATTERN % device_info
            if device_info['netsetup'] == NetSetup.LAN:
                lan_nodes_confs.append(conf)
            else:
                nat_nodes_confs.append(conf)
        elif device_info['type'] == 'unknown':
            unknowns_confs.append(UNKNOWNS_CONF_PATTERN % device_info)
        else:
            raise NotImplementedError("Unexpected type '%s' in dhcpd.conf" % device_info['type'])
        if device_info['ip'] in free_ips:
            free_ips.remove(device_info['ip'])
    range_confs = []
    for r in get_contiguous_ranges(free_ips):
        first, last = r
        range_confs.append(
            RANGE_CONF_PATTERN % dict(
                    first=first,
                    last=last
        ))
    infos = dict(
        walt_server_ip=server_ip,
        subnet_ip=subnet.network_address,
        subnet_broadcast=subnet.broadcast_address,
        subnet_netmask=subnet.netmask,
        dns_servers=", ".join(get_dns_servers()),
        walt_registered_switches_conf='\n'.join(switches_confs),
        walt_registered_lan_nodes_conf='\n'.join(lan_nodes_confs),
        walt_registered_nat_nodes_conf='\n'.join(nat_nodes_confs),
        walt_registered_unknowns_conf='\n'.join(unknowns_confs),
        walt_unallocated_ranges_conf='\n'.join(range_confs)
    )
    return CONF_PATTERN % infos

QUERY_DEVICES_WITH_IP="""
    SELECT devices.mac, ip, name, type, COALESCE((conf->'netsetup')::int, 0) as netsetup
    FROM devices LEFT JOIN nodes ON devices.mac = nodes.mac
    WHERE ip IS NOT NULL ORDER BY devices.mac;
"""

class DHCPServer(object):
    def __init__(self, db):
        self.db = db
    def update(self, force=False):
        subnet = get_walt_subnet()
        devices = []
        for item in \
                self.db.execute(QUERY_DEVICES_WITH_IP).fetchall():
            device_ip = ip(item.ip)
            if device_ip not in subnet:
                continue
            if item.type != 'server':
                devices.append(dict(
                    type=item.type,
                    hostname=item.name,
                    ip=device_ip,
                    mac=item.mac,
                    netsetup=item.netsetup))
        conf = generate_dhcpd_conf(subnet, devices)
        with open(DHCPD_CONF_FILE, 'r') as conf_file:
            old_conf = conf_file.read()
        if conf != old_conf:
            with open(DHCPD_CONF_FILE, 'w') as conf_file:
                conf_file.write(conf)
            force = True # perform the restart below
        if force == True:
            do('service isc-dhcp-server restart')
            print('dhcpd conf updated.')

